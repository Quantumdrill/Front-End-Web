import {
  c,
  r,
  s
} from "./chunk-HA2BHINR.js";
import {
  __privateAdd,
  __privateGet,
  __privateSet,
  __publicField
} from "./chunk-TKZWA4SW.js";

// node_modules/get-it/dist/index.browser.js
var o = ["request", "response", "progress", "error", "abort"];
var s2 = ["processOptions", "validateOptions", "interceptRequest", "finalizeOptions", "onRequest", "onResponse", "onError", "onReturn", "onHeaders"];
function n(r2, a2) {
  const i2 = [], u2 = s2.reduce((e, t) => (e[t] = e[t] || [], e), { processOptions: [r], validateOptions: [s] });
  function l2(e) {
    const t = o.reduce((e2, t2) => (e2[t2] = /* @__PURE__ */ function() {
      const e3 = /* @__PURE__ */ Object.create(null);
      let t3 = 0;
      return { publish: function(t4) {
        for (const r4 in e3) e3[r4](t4);
      }, subscribe: function(r4) {
        const o2 = t3++;
        return e3[o2] = r4, function() {
          delete e3[o2];
        };
      } };
    }(), e2), {}), r3 = /* @__PURE__ */ ((e2) => function(t2, r4, ...o2) {
      const s4 = "onError" === t2;
      let n3 = r4;
      for (let r5 = 0; r5 < e2[t2].length && (n3 = (0, e2[t2][r5])(n3, ...o2), !s4 || n3); r5++) ;
      return n3;
    })(u2), s3 = r3("processOptions", e);
    r3("validateOptions", s3);
    const n2 = { options: s3, channels: t, applyMiddleware: r3 };
    let i3;
    const l3 = t.request.subscribe((e2) => {
      i3 = a2(e2, (o2, s4) => ((e3, o3, s5) => {
        let n3 = e3, a3 = o3;
        if (!n3) try {
          a3 = r3("onResponse", o3, s5);
        } catch (e4) {
          a3 = null, n3 = e4;
        }
        n3 = n3 && r3("onError", n3, s5), n3 ? t.error.publish(n3) : a3 && t.response.publish(a3);
      })(o2, s4, e2));
    });
    t.abort.subscribe(() => {
      l3(), i3 && i3.abort();
    });
    const c3 = r3("onReturn", t, n2);
    return c3 === t && t.request.publish(n2), c3;
  }
  return l2.use = function(e) {
    if (!e) throw new Error("Tried to add middleware that resolved to falsey value");
    if ("function" == typeof e) throw new Error("Tried to add middleware that was a function. It probably expects you to pass options to it.");
    if (e.onReturn && u2.onReturn.length > 0) throw new Error("Tried to add new middleware with `onReturn` handler, but another handler has already been registered for this event");
    return s2.forEach((t) => {
      e[t] && u2[t].push(e[t]);
    }), i2.push(e), l2;
  }, l2.clone = () => n(i2, a2), r2.forEach(l2.use), l2;
}
var a = function(e) {
  return e.replace(/^\s+|\s+$/g, "");
};
var i = c(function(e) {
  if (!e) return {};
  for (var t = {}, r2 = a(e).split("\n"), o2 = 0; o2 < r2.length; o2++) {
    var s3 = r2[o2], n2 = s3.indexOf(":"), i2 = a(s3.slice(0, n2)).toLowerCase(), u2 = a(s3.slice(n2 + 1));
    typeof t[i2] > "u" ? t[i2] = u2 : (l2 = t[i2], "[object Array]" === Object.prototype.toString.call(l2) ? t[i2].push(u2) : t[i2] = [t[i2], u2]);
  }
  var l2;
  return t;
});
var _e, _t, _r, _o, _s, _n, _a;
var u = class {
  constructor() {
    __publicField(this, "onabort");
    __publicField(this, "onerror");
    __publicField(this, "onreadystatechange");
    __publicField(this, "ontimeout");
    __publicField(this, "readyState", 0);
    __publicField(this, "response");
    __publicField(this, "responseText", "");
    __publicField(this, "responseType", "");
    __publicField(this, "status");
    __publicField(this, "statusText");
    __publicField(this, "withCredentials");
    __privateAdd(this, _e);
    __privateAdd(this, _t);
    __privateAdd(this, _r);
    __privateAdd(this, _o, {});
    __privateAdd(this, _s);
    __privateAdd(this, _n, {});
    __privateAdd(this, _a);
  }
  open(e, t, r2) {
    var _a2;
    __privateSet(this, _e, e), __privateSet(this, _t, t), __privateSet(this, _r, ""), this.readyState = 1, (_a2 = this.onreadystatechange) == null ? void 0 : _a2.call(this), __privateSet(this, _s, void 0);
  }
  abort() {
    __privateGet(this, _s) && __privateGet(this, _s).abort();
  }
  getAllResponseHeaders() {
    return __privateGet(this, _r);
  }
  setRequestHeader(e, t) {
    __privateGet(this, _o)[e] = t;
  }
  setInit(e, t = true) {
    __privateSet(this, _n, e), __privateSet(this, _a, t);
  }
  send(e) {
    const t = "arraybuffer" !== this.responseType, r2 = { ...__privateGet(this, _n), method: __privateGet(this, _e), headers: __privateGet(this, _o), body: e };
    "function" == typeof AbortController && __privateGet(this, _a) && (__privateSet(this, _s, new AbortController()), typeof EventTarget < "u" && __privateGet(this, _s).signal instanceof EventTarget && (r2.signal = __privateGet(this, _s).signal)), typeof document < "u" && (r2.credentials = this.withCredentials ? "include" : "omit"), fetch(__privateGet(this, _t), r2).then((e2) => {
      var _a2;
      return e2.headers.forEach((e3, t2) => {
        __privateSet(this, _r, __privateGet(this, _r) + `${t2}: ${e3}\r
`);
      }), this.status = e2.status, this.statusText = e2.statusText, this.readyState = 3, (_a2 = this.onreadystatechange) == null ? void 0 : _a2.call(this), t ? e2.text() : e2.arrayBuffer();
    }).then((e2) => {
      var _a2;
      "string" == typeof e2 ? this.responseText = e2 : this.response = e2, this.readyState = 4, (_a2 = this.onreadystatechange) == null ? void 0 : _a2.call(this);
    }).catch((e2) => {
      var _a2, _b;
      "AbortError" !== e2.name ? (_a2 = this.onerror) == null ? void 0 : _a2.call(this, e2) : (_b = this.onabort) == null ? void 0 : _b.call(this);
    });
  }
};
_e = new WeakMap();
_t = new WeakMap();
_r = new WeakMap();
_o = new WeakMap();
_s = new WeakMap();
_n = new WeakMap();
_a = new WeakMap();
var l = "function" == typeof XMLHttpRequest ? "xhr" : "fetch";
var c2 = "xhr" === l ? XMLHttpRequest : u;
var h = (e, t) => {
  const r2 = e.options, o2 = e.applyMiddleware("finalizeOptions", r2), s3 = {}, n2 = e.applyMiddleware("interceptRequest", void 0, { adapter: l, context: e });
  if (n2) {
    const e2 = setTimeout(t, 0, null, n2);
    return { abort: () => clearTimeout(e2) };
  }
  let a2 = new c2();
  a2 instanceof u && "object" == typeof o2.fetch && a2.setInit(o2.fetch, o2.useAbortSignal ?? true);
  const h2 = o2.headers, d2 = o2.timeout;
  let p2 = false, f = false, b = false;
  if (a2.onerror = (e2) => {
    m(a2 instanceof u ? e2 instanceof Error ? e2 : new Error(`Request error while attempting to reach is ${o2.url}`, { cause: e2 }) : new Error(`Request error while attempting to reach is ${o2.url}${e2.lengthComputable ? `(${e2.loaded} of ${e2.total} bytes transferred)` : ""}`));
  }, a2.ontimeout = (e2) => {
    m(new Error(`Request timeout while attempting to reach ${o2.url}${e2.lengthComputable ? `(${e2.loaded} of ${e2.total} bytes transferred)` : ""}`));
  }, a2.onabort = () => {
    w(true), p2 = true;
  }, a2.onreadystatechange = () => {
    d2 && (w(), s3.socket = setTimeout(() => y("ESOCKETTIMEDOUT"), d2.socket)), !p2 && 4 === a2.readyState && 0 !== a2.status && function() {
      if (!(p2 || f || b)) {
        if (0 === a2.status) return void m(new Error("Unknown XHR error"));
        w(), f = true, t(null, { body: a2.response || ("" === a2.responseType || "text" === a2.responseType ? a2.responseText : ""), url: o2.url, method: o2.method, headers: i(a2.getAllResponseHeaders()), statusCode: a2.status, statusMessage: a2.statusText });
      }
    }();
  }, a2.open(o2.method, o2.url, true), a2.withCredentials = !!o2.withCredentials, h2 && a2.setRequestHeader) for (const e2 in h2) h2.hasOwnProperty(e2) && a2.setRequestHeader(e2, h2[e2]);
  return o2.rawBody && (a2.responseType = "arraybuffer"), e.applyMiddleware("onRequest", { options: o2, adapter: l, request: a2, context: e }), a2.send(o2.body || null), d2 && (s3.connect = setTimeout(() => y("ETIMEDOUT"), d2.connect)), { abort: function() {
    p2 = true, a2 && a2.abort();
  } };
  function y(t2) {
    b = true, a2.abort();
    const r3 = new Error("ESOCKETTIMEDOUT" === t2 ? `Socket timed out on request to ${o2.url}` : `Connection timed out on request to ${o2.url}`);
    r3.code = t2, e.channels.error.publish(r3);
  }
  function w(e2) {
    (e2 || p2 || a2.readyState >= 2 && s3.connect) && clearTimeout(s3.connect), s3.socket && clearTimeout(s3.socket);
  }
  function m(e2) {
    if (f) return;
    w(true), f = true, a2 = null;
    const r3 = e2 || new Error(`Network error while attempting to reach ${o2.url}`);
    r3.isNetworkError = true, r3.request = o2, t(r3);
  }
};
var d = (e = [], t = h) => n(e, t);
var p = "browser";
export {
  l as adapter,
  p as environment,
  d as getIt
};
//# sourceMappingURL=get-it.js.map
