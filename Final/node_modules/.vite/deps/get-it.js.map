{
  "version": 3,
  "sources": ["../../get-it/src/util/middlewareReducer.ts", "../../get-it/src/createRequester.ts", "../../get-it/src/util/pubsub.ts", "../../get-it/node_modules/parse-headers/parse-headers.js", "../../get-it/src/request/browser/fetchXhr.ts", "../../get-it/src/request/browser-request.ts", "../../get-it/src/index.browser.ts"],
  "sourcesContent": ["import type {ApplyMiddleware, MiddlewareReducer} from 'get-it'\n\nexport const middlewareReducer = (middleware: MiddlewareReducer) =>\n  function applyMiddleware(hook, defaultValue, ...args) {\n    const bailEarly = hook === 'onError'\n\n    let value = defaultValue\n    for (let i = 0; i < middleware[hook].length; i++) {\n      const handler = middleware[hook][i]\n      // @ts-expect-error -- find a better way to deal with argument tuples\n      value = handler(value, ...args)\n\n      if (bailEarly && !value) {\n        break\n      }\n    }\n\n    return value\n  } as ApplyMiddleware\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {processOptions} from './middleware/defaultOptionsProcessor'\nimport {validateOptions} from './middleware/defaultOptionsValidator'\nimport type {\n  HttpContext,\n  HttpRequest,\n  HttpRequestOngoing,\n  Middleware,\n  MiddlewareChannels,\n  MiddlewareHooks,\n  MiddlewareReducer,\n  MiddlewareResponse,\n  Middlewares,\n  Requester,\n  RequestOptions,\n} from './types'\nimport {middlewareReducer} from './util/middlewareReducer'\nimport {createPubSub} from './util/pubsub'\n\nconst channelNames = [\n  'request',\n  'response',\n  'progress',\n  'error',\n  'abort',\n] satisfies (keyof MiddlewareChannels)[]\nconst middlehooks = [\n  'processOptions',\n  'validateOptions',\n  'interceptRequest',\n  'finalizeOptions',\n  'onRequest',\n  'onResponse',\n  'onError',\n  'onReturn',\n  'onHeaders',\n] satisfies (keyof MiddlewareHooks)[]\n\n/** @public */\nexport function createRequester(initMiddleware: Middlewares, httpRequest: HttpRequest): Requester {\n  const loadedMiddleware: Middlewares = []\n  const middleware: MiddlewareReducer = middlehooks.reduce(\n    (ware, name) => {\n      ware[name] = ware[name] || []\n      return ware\n    },\n    {\n      processOptions: [processOptions],\n      validateOptions: [validateOptions],\n    } as any,\n  )\n\n  function request(opts: RequestOptions | string) {\n    const onResponse = (reqErr: Error | null, res: MiddlewareResponse, ctx: HttpContext) => {\n      let error = reqErr\n      let response: MiddlewareResponse | null = res\n\n      // We're processing non-errors first, in case a middleware converts the\n      // response into an error (for instance, status >= 400 == HttpError)\n      if (!error) {\n        try {\n          response = applyMiddleware('onResponse', res, ctx)\n        } catch (err: any) {\n          response = null\n          error = err\n        }\n      }\n\n      // Apply error middleware - if middleware return the same (or a different) error,\n      // publish as an error event. If we *don't* return an error, assume it has been handled\n      error = error && applyMiddleware('onError', error, ctx)\n\n      // Figure out if we should publish on error/response channels\n      if (error) {\n        channels.error.publish(error)\n      } else if (response) {\n        channels.response.publish(response)\n      }\n    }\n\n    const channels: MiddlewareChannels = channelNames.reduce((target, name) => {\n      target[name] = createPubSub() as MiddlewareChannels[typeof name]\n      return target\n    }, {} as any)\n\n    // Prepare a middleware reducer that can be reused throughout the lifecycle\n    const applyMiddleware = middlewareReducer(middleware)\n\n    // Parse the passed options\n    const options = applyMiddleware('processOptions', opts as RequestOptions)\n\n    // Validate the options\n    applyMiddleware('validateOptions', options)\n\n    // Build a context object we can pass to child handlers\n    const context = {options, channels, applyMiddleware}\n\n    // We need to hold a reference to the current, ongoing request,\n    // in order to allow cancellation. In the case of the retry middleware,\n    // a new request might be triggered\n    let ongoingRequest: HttpRequestOngoing | undefined\n    const unsubscribe = channels.request.subscribe((ctx) => {\n      // Let request adapters (node/browser) perform the actual request\n      ongoingRequest = httpRequest(ctx, (err, res) => onResponse(err, res!, ctx))\n    })\n\n    // If we abort the request, prevent further requests from happening,\n    // and be sure to cancel any ongoing request (obviously)\n    channels.abort.subscribe(() => {\n      unsubscribe()\n      if (ongoingRequest) {\n        ongoingRequest.abort()\n      }\n    })\n\n    // See if any middleware wants to modify the return value - for instance\n    // the promise or observable middlewares\n    const returnValue = applyMiddleware('onReturn', channels, context)\n\n    // If return value has been modified by a middleware, we expect the middleware\n    // to publish on the 'request' channel. If it hasn't been modified, we want to\n    // trigger it right away\n    if (returnValue === channels) {\n      channels.request.publish(context)\n    }\n\n    return returnValue\n  }\n\n  request.use = function use(newMiddleware: Middleware) {\n    if (!newMiddleware) {\n      throw new Error('Tried to add middleware that resolved to falsey value')\n    }\n\n    if (typeof newMiddleware === 'function') {\n      throw new Error(\n        'Tried to add middleware that was a function. It probably expects you to pass options to it.',\n      )\n    }\n\n    if (newMiddleware.onReturn && middleware.onReturn.length > 0) {\n      throw new Error(\n        'Tried to add new middleware with `onReturn` handler, but another handler has already been registered for this event',\n      )\n    }\n\n    middlehooks.forEach((key) => {\n      if (newMiddleware[key]) {\n        middleware[key].push(newMiddleware[key] as any)\n      }\n    })\n\n    loadedMiddleware.push(newMiddleware)\n    return request\n  }\n\n  request.clone = () => createRequester(loadedMiddleware, httpRequest)\n\n  initMiddleware.forEach(request.use)\n\n  return request\n}\n", "// Code borrowed from https://github.com/bjoerge/nano-pubsub\n\nimport type {PubSub, Subscriber} from 'get-it'\n\nexport function createPubSub<Message = void>(): PubSub<Message> {\n  const subscribers: {[id: string]: Subscriber<Message>} = Object.create(null)\n  let nextId = 0\n  function subscribe(subscriber: Subscriber<Message>) {\n    const id = nextId++\n    subscribers[id] = subscriber\n    return function unsubscribe() {\n      delete subscribers[id]\n    }\n  }\n\n  function publish(event: Message) {\n    for (const id in subscribers) {\n      subscribers[id](event)\n    }\n  }\n\n  return {\n    publish,\n    subscribe,\n  }\n}\n", "var trim = function(string) {\n  return string.replace(/^\\s+|\\s+$/g, '');\n}\n  , isArray = function(arg) {\n      return Object.prototype.toString.call(arg) === '[object Array]';\n    }\n\nmodule.exports = function (headers) {\n  if (!headers)\n    return {}\n\n  var result = {}\n\n  var headersArr = trim(headers).split('\\n')\n\n  for (var i = 0; i < headersArr.length; i++) {\n    var row = headersArr[i]\n    var index = row.indexOf(':')\n    , key = trim(row.slice(0, index)).toLowerCase()\n    , value = trim(row.slice(index + 1))\n\n    if (typeof(result[key]) === 'undefined') {\n      result[key] = value\n    } else if (isArray(result[key])) {\n      result[key].push(value)\n    } else {\n      result[key] = [ result[key], value ]\n    }\n  }\n\n  return result\n}\n", "/**\n * Mimicks the XMLHttpRequest API with only the parts needed for get-it's XHR adapter\n */\nexport class FetchXhr\n  implements Pick<XMLHttpRequest, 'open' | 'abort' | 'getAllResponseHeaders' | 'setRequestHeader'>\n{\n  /**\n   * Public interface, interop with real XMLHttpRequest\n   */\n  onabort: (() => void) | undefined\n  onerror: ((error?: any) => void) | undefined\n  onreadystatechange: (() => void) | undefined\n  ontimeout: XMLHttpRequest['ontimeout'] | undefined\n  /**\n   * https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/readyState\n   */\n  readyState: 0 | 1 | 2 | 3 | 4 = 0\n  response: XMLHttpRequest['response']\n  responseText: XMLHttpRequest['responseText'] = ''\n  responseType: XMLHttpRequest['responseType'] = ''\n  status: XMLHttpRequest['status'] | undefined\n  statusText: XMLHttpRequest['statusText'] | undefined\n  withCredentials: XMLHttpRequest['withCredentials'] | undefined\n\n  /**\n   * Private implementation details\n   */\n  #method!: string\n  #url!: string\n  #resHeaders!: string\n  #headers: Record<string, string> = {}\n  #controller?: AbortController\n  #init: RequestInit = {}\n  #useAbortSignal?: boolean\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars -- _async is only declared for typings compatibility\n  open(method: string, url: string, _async?: boolean) {\n    this.#method = method\n    this.#url = url\n    this.#resHeaders = ''\n    this.readyState = 1 // Open\n    this.onreadystatechange?.()\n    this.#controller = undefined\n  }\n  abort() {\n    if (this.#controller) {\n      this.#controller.abort()\n    }\n  }\n  getAllResponseHeaders() {\n    return this.#resHeaders\n  }\n  setRequestHeader(name: string, value: string) {\n    this.#headers[name] = value\n  }\n  // Allow setting extra fetch init options, needed for runtimes such as Vercel Edge to set `cache` and other options in React Server Components\n  setInit(init: RequestInit, useAbortSignal = true) {\n    this.#init = init\n    this.#useAbortSignal = useAbortSignal\n  }\n  send(body: BodyInit) {\n    const textBody = this.responseType !== 'arraybuffer'\n    const options: RequestInit = {\n      ...this.#init,\n      method: this.#method,\n      headers: this.#headers,\n      body,\n    }\n    if (typeof AbortController === 'function' && this.#useAbortSignal) {\n      this.#controller = new AbortController()\n      // The instanceof check ensures environments like Edge Runtime, Node 18 with built-in fetch\n      // and more don't throw if `signal` doesn't implement`EventTarget`\n      // Native browser AbortSignal implements EventTarget, so we can use it\n      if (typeof EventTarget !== 'undefined' && this.#controller.signal instanceof EventTarget) {\n        options.signal = this.#controller.signal\n      }\n    }\n\n    // Some environments (like CloudFlare workers) don't support credentials in\n    // RequestInitDict, and there doesn't seem to be any easy way to check for it,\n    // so for now let's just make do with a document check :/\n    if (typeof document !== 'undefined') {\n      options.credentials = this.withCredentials ? 'include' : 'omit'\n    }\n\n    fetch(this.#url, options)\n      .then((res): Promise<string | ArrayBuffer> => {\n        res.headers.forEach((value: any, key: any) => {\n          this.#resHeaders += `${key}: ${value}\\r\\n`\n        })\n        this.status = res.status\n        this.statusText = res.statusText\n        this.readyState = 3 // Loading\n        this.onreadystatechange?.()\n        return textBody ? res.text() : res.arrayBuffer()\n      })\n      .then((resBody) => {\n        if (typeof resBody === 'string') {\n          this.responseText = resBody\n        } else {\n          this.response = resBody\n        }\n        this.readyState = 4 // Done\n        this.onreadystatechange?.()\n      })\n      .catch((err: Error) => {\n        if (err.name === 'AbortError') {\n          this.onabort?.()\n          return\n        }\n\n        this.onerror?.(err)\n      })\n  }\n}\n", "import type {HttpRequest, MiddlewareResponse, RequestOptions} from 'get-it'\nimport parseHeaders from 'parse-headers'\n\nimport {FetchXhr} from './browser/fetchXhr'\n\n/**\n * Use fetch if it's available, non-browser environments such as Deno, Edge Runtime and more provide fetch as a global but doesn't provide xhr\n * @public\n */\nexport const adapter = (\n  typeof XMLHttpRequest === 'function' ? ('xhr' as const) : ('fetch' as const)\n) satisfies import('../types').RequestAdapter\n\n// Fallback to fetch-based XHR polyfill for non-browser environments like Workers\nconst XmlHttpRequest = adapter === 'xhr' ? XMLHttpRequest : FetchXhr\n\nexport const httpRequester: HttpRequest = (context, callback) => {\n  const opts = context.options\n  const options = context.applyMiddleware('finalizeOptions', opts) as RequestOptions\n  const timers: any = {}\n\n  // Allow middleware to inject a response, for instance in the case of caching or mocking\n  const injectedResponse = context.applyMiddleware('interceptRequest', undefined, {\n    adapter,\n    context,\n  })\n\n  // If middleware injected a response, treat it as we normally would and return it\n  // Do note that the injected response has to be reduced to a cross-environment friendly response\n  if (injectedResponse) {\n    const cbTimer = setTimeout(callback, 0, null, injectedResponse)\n    const cancel = () => clearTimeout(cbTimer)\n    return {abort: cancel}\n  }\n\n  // We'll want to null out the request on success/failure\n  let xhr = new XmlHttpRequest()\n\n  if (xhr instanceof FetchXhr && typeof options.fetch === 'object') {\n    xhr.setInit(options.fetch, options.useAbortSignal ?? true)\n  }\n\n  const headers = options.headers\n  const delays = options.timeout\n\n  // Request state\n  let aborted = false\n  let loaded = false\n  let timedOut = false\n\n  // Apply event handlers\n  xhr.onerror = (event: ProgressEvent) => {\n    // If fetch is used then rethrow the original error\n    if (xhr instanceof FetchXhr) {\n      onError(\n        event instanceof Error\n          ? event\n          : new Error(`Request error while attempting to reach is ${options.url}`, {cause: event}),\n      )\n    } else {\n      onError(\n        new Error(\n          `Request error while attempting to reach is ${options.url}${\n            event.lengthComputable ? `(${event.loaded} of ${event.total} bytes transferred)` : ''\n          }`,\n        ),\n      )\n    }\n  }\n  xhr.ontimeout = (event: ProgressEvent) => {\n    onError(\n      new Error(\n        `Request timeout while attempting to reach ${options.url}${\n          event.lengthComputable ? `(${event.loaded} of ${event.total} bytes transferred)` : ''\n        }`,\n      ),\n    )\n  }\n  xhr.onabort = () => {\n    stopTimers(true)\n    aborted = true\n  }\n\n  xhr.onreadystatechange = () => {\n    // Prevent request from timing out\n    resetTimers()\n\n    if (aborted || xhr.readyState !== 4) {\n      return\n    }\n\n    // Will be handled by onError\n    if (xhr.status === 0) {\n      return\n    }\n\n    onLoad()\n  }\n\n  // @todo two last options to open() is username/password\n  xhr.open(\n    options.method!,\n    options.url,\n    true, // Always async\n  )\n\n  // Some options need to be applied after open\n  xhr.withCredentials = !!options.withCredentials\n\n  // Set headers\n  if (headers && xhr.setRequestHeader) {\n    for (const key in headers) {\n      // eslint-disable-next-line no-prototype-builtins\n      if (headers.hasOwnProperty(key)) {\n        xhr.setRequestHeader(key, headers[key])\n      }\n    }\n  }\n\n  if (options.rawBody) {\n    xhr.responseType = 'arraybuffer'\n  }\n\n  // Let middleware know we're about to do a request\n  context.applyMiddleware('onRequest', {options, adapter, request: xhr, context})\n\n  xhr.send(options.body || null)\n\n  // Figure out which timeouts to use (if any)\n  if (delays) {\n    timers.connect = setTimeout(() => timeoutRequest('ETIMEDOUT'), delays.connect)\n  }\n\n  return {abort}\n\n  function abort() {\n    aborted = true\n\n    if (xhr) {\n      xhr.abort()\n    }\n  }\n\n  function timeoutRequest(code: any) {\n    timedOut = true\n    xhr.abort()\n    const error: any = new Error(\n      code === 'ESOCKETTIMEDOUT'\n        ? `Socket timed out on request to ${options.url}`\n        : `Connection timed out on request to ${options.url}`,\n    )\n    error.code = code\n    context.channels.error.publish(error)\n  }\n\n  function resetTimers() {\n    if (!delays) {\n      return\n    }\n\n    stopTimers()\n    timers.socket = setTimeout(() => timeoutRequest('ESOCKETTIMEDOUT'), delays.socket)\n  }\n\n  function stopTimers(force?: boolean) {\n    // Only clear the connect timeout if we've got a connection\n    if (force || aborted || (xhr.readyState >= 2 && timers.connect)) {\n      clearTimeout(timers.connect)\n    }\n\n    if (timers.socket) {\n      clearTimeout(timers.socket)\n    }\n  }\n\n  function onError(error: Error) {\n    if (loaded) {\n      return\n    }\n\n    // Clean up\n    stopTimers(true)\n    loaded = true\n    ;(xhr as any) = null\n\n    // Annoyingly, details are extremely scarce and hidden from us.\n    // We only really know that it is a network error\n    const err = (error ||\n      new Error(`Network error while attempting to reach ${options.url}`)) as Error & {\n      isNetworkError: boolean\n      request?: typeof options\n    }\n    err.isNetworkError = true\n    err.request = options\n    callback(err)\n  }\n\n  function reduceResponse(): MiddlewareResponse {\n    return {\n      body:\n        xhr.response ||\n        (xhr.responseType === '' || xhr.responseType === 'text' ? xhr.responseText : ''),\n      url: options.url,\n      method: options.method!,\n      headers: parseHeaders(xhr.getAllResponseHeaders()),\n      statusCode: xhr.status!,\n      statusMessage: xhr.statusText!,\n    }\n  }\n\n  function onLoad() {\n    if (aborted || loaded || timedOut) {\n      return\n    }\n\n    if (xhr.status === 0) {\n      onError(new Error('Unknown XHR error'))\n      return\n    }\n\n    // Prevent being called twice\n    stopTimers()\n    loaded = true\n    callback(null, reduceResponse())\n  }\n}\n", "import {createRequester} from './createRequester'\nimport {httpRequester} from './request/browser-request'\nimport type {ExportEnv, HttpRequest, Middlewares, Requester} from './types'\n\nexport type * from './types'\n\n/** @public */\nexport const getIt = (\n  initMiddleware: Middlewares = [],\n  httpRequest: HttpRequest = httpRequester,\n): Requester => createRequester(initMiddleware, httpRequest)\n\n/** @public */\nexport const environment = 'browser' satisfies ExportEnv\n\n/** @public */\nexport {adapter} from './request/browser-request'\n"],
  "mappings": ";;;;;;;;;;;;;ACmBA,IAAMA,IAAe,CACnB,WACA,YACA,YACA,SACA,OAAA;AALF,IAOMC,KAAc,CAClB,kBACA,mBACA,oBACA,mBACA,aACA,cACA,WACA,YACA,WAAA;AAIc,SAAAC,EAAgBC,IAA6BC,IAAAA;AAC3D,QAAMC,KAAgC,CAAA,GAChCC,KAAgCL,GAAYM,OAChD,CAACC,GAAMC,OACLD,EAAKC,CAAAA,IAAQD,EAAKC,CAAAA,KAAS,CAAA,GACpBD,IAET,EACEE,gBAAgB,CAACA,CAAAA,GACjBC,iBAAiB,CAACA,CAAAA,EAAAA,CAAAA;AAItB,WAASC,GAAQC,GAAAA;AACf,UA2BMC,IAA+Bd,EAAaO,OAAO,CAACQ,IAAQN,QAChEM,GAAON,EAAAA,IC7EN,2BAAA;AACC,YAAAO,KAA0DC,uBAAAC,OAAO,IAAA;AACvE,UAAIC,KAAS;AAeN,aAAA,EACLC,SAPF,SAAiBC,IAAAA;AACf,mBAAWC,MAAMN,GACHA,CAAAA,GAAAM,EAAAA,EAAID,EAAAA;MAEpB,GAIEE,WAhBF,SAAmBC,IAAAA;AACjB,cAAMF,KAAKH;AACC,eAAAH,GAAAM,EAAAA,IAAME,IACX,WAAA;AAAA,iBACER,GAAYM,EAAAA;QAAE;MAEzB,EAAA;IAYF,EDwDqBG,GACRV,KACN,CAAS,CAAA,GAGNW,KDpFwBpB,kBAAAA,OAChC,SAAyBqB,IAAMC,OAAiBC,IAAAA;AAC9C,YAAMC,KAAqB,cAATH;AAElB,UAAII,KAAQH;AACZ,eAASI,KAAI,GAAGA,KAAI1B,GAAWqB,EAAAA,EAAMM,WAGnCF,MAAQG,GAFQ5B,GAAWqB,EAAAA,EAAMK,EAAAA,GAEjBD,IAAAA,GAAUF,EAAAA,GAAAA,CAEtBC,MAAcC,KALyBC,KAAAA;AAUtC,aAAAD;IACT,GCoE4CzB,EAAAA,GAGpC6B,KAAUT,GAAgB,kBAAkBb,CAAAA;AAGlDa,IAAAA,GAAgB,mBAAmBS,EAAAA;AAGnC,UAAMC,KAAU,EAACD,SAAAA,IAASrB,UAAAA,GAAUY,iBAAAA,GAAAA;AAKhC,QAAAW;AACJ,UAAMC,KAAcxB,EAASF,QAAQW,UAAWgB,CAAAA,OAAAA;AAE7BF,MAAAA,KAAAjC,GAAYmC,IAAK,CAACC,IAAKC,QAlDvB,CAACC,IAAsBD,IAAyBF,OAAAA;AAC7D,YAAAI,KAAQD,IACRE,KAAsCH;AAI1C,YAAA,CAAKE,GACC,KAAA;AACSC,UAAAA,KAAAlB,GAAgB,cAAce,IAAKF,EAAAA;QAAAA,SACvCC,IAAAA;AACPI,UAAAA,KAAW,MACXD,KAAQH;QACV;AAKFG,QAAAA,KAAQA,MAASjB,GAAgB,WAAWiB,IAAOJ,EAAAA,GAG/CI,KACF7B,EAAS6B,MAAMvB,QAAQuB,EAAAA,IACdC,MACT9B,EAAS8B,SAASxB,QAAQwB,EAAAA;MAAQ,GA2BuBJ,IAAKC,IAAMF,EAAAA,CAAAA;IAAI,CAAA;AAKnEzB,MAAA+B,MAAMtB,UAAU,MAAA;AAAA,MAAAuB,GAAA,GAEnBT,MACFA,GAAeQ,MAAAA;IAAM,CAAA;AAMzB,UAAME,KAAcrB,GAAgB,YAAYZ,GAAUsB,EAAAA;AAK1D,WAAIW,OAAgBjC,KAClBA,EAASF,QAAQQ,QAAQgB,EAAAA,GAGpBW;EACT;AAEQ,SAAAnC,GAAAoC,MAAM,SAAaC,GAAAA;AACzB,QAAA,CAAKA,EACG,OAAA,IAAIC,MAAM,uDAAA;AAGlB,QAA6B,cAAA,OAAlBD,EACT,OAAM,IAAIC,MACR,6FAAA;AAIJ,QAAID,EAAcE,YAAY7C,GAAW6C,SAASlB,SAAS,EACzD,OAAM,IAAIiB,MACR,qHAAA;AAIQ,WAAAjD,GAAAmD,QAASC,OAAAA;AACDJ,QAAAI,CAAAA,KAChB/C,GAAW+C,CAAAA,EAAKC,KAAKL,EAAcI,CAAAA,CAAAA;IAAW,CAAA,GAIlDhD,GAAiBiD,KAAKL,CAAAA,GACfrC;EAGT,GAAAA,GAAQ2C,QAAQ,MAAMrD,EAAgBG,IAAkBD,EAAAA,GAExDD,GAAeiD,QAAQxC,GAAQoC,GAAAA,GAExBpC;AACT;AEjKA,IAAI4C,IAAO,SAASC,GAAAA;AACX,SAAAA,EAAOC,QAAQ,cAAc,EAAA;AACtC;AAFA,IAEA,IAAA,EAKiB,SAAUC,GAAAA;AACzB,MAAA,CAAKA,EACH,QAAO,CAAE;AAMX,WAJIC,IAAS,CAAE,GAEXC,KAAaL,EAAKG,CAAAA,EAASG,MAAM,IAAA,GAE5B9B,KAAI,GAAGA,KAAI6B,GAAW5B,QAAQD,MAAK;AACtC,QAAA+B,KAAMF,GAAW7B,EAAAA,GACjBgC,KAAQD,GAAIE,QAAQ,GAAA,GACtBZ,KAAMG,EAAKO,GAAIG,MAAM,GAAGF,EAAAA,CAAAA,EAAQG,YAAAA,GAChCpC,KAAQyB,EAAKO,GAAIG,MAAMF,KAAQ,CAAA,CAAA;AAAA,WAEtBJ,EAAOP,EAAAA,IAAU,MAC1BO,EAAOP,EAAAA,IAAOtB,MAnBGqC,KAoBAR,EAAOP,EAAAA,GAnBuB,qBAAxCpC,OAAOoD,UAAUC,SAASC,KAAKH,EAAAA,IAoBtCR,EAAOP,EAAAA,EAAKC,KAAKvB,EAAAA,IAEjB6B,EAAOP,EAAAA,IAAO,CAAEO,EAAOP,EAAAA,GAAMtB,EAAAA;EAEhC;AAzBW,MAASqC;AA2Bd,SAAAR;AACT,CAAA;;AC5BO,IAAMY,IAAN,MAAMA;EAAN;AAMLC;AACAC;AACAC;AACAC;AAIAC,sCAAgC;AAChCjC;AACAkC,wCAA+C;AAC/CC,wCAA+C;AAC/CC;AACAC;AACAC;AAKAC;AACAC;AACAC;AACA1B,2BAAmC,CAAA;AACnC2B;AACAC,2BAAqB,CAAA;AACrBC;;EAEA,KAAKL,GAAgBC,GAAaK,IAAAA;;AAChCC,uBAAAA,IAAeP,IACfO,mBAAAA,IAAYN,IACZM,mBAAAA,IAAmB,KACnBA,KAAKb,aAAa,IAClBa,MAAAA,KAAKf,uBAALe,gBAAAA,IAAAA,YACAA,mBAAAA,IAAKJ;EACP;EACA,QAAAzC;AACW6C,uBAAAA,OACPA,mBAAAA,IAAiB7C,MAAAA;EAErB;EACA,wBAAA8C;AACE,WAAOD,mBAAAA;EACT;EACA,iBAAiBjF,GAAcsB,GAAAA;AACxB2D,uBAAAA,IAASjF,CAAAA,IAAQsB;EACxB;EAEA,QAAQwD,GAAmBC,IAAAA,MAAiB;AACrCE,uBAAAA,IAAQH,IACbG,mBAAAA,IAAuBF;EACzB;EACA,KAAKI,GAAAA;AACH,UAAMC,IAAiC,kBAAtBH,KAAKX,cAChB5C,KAAuB,EAAA,GACxBuD,mBAAAA,KACHP,QAAQO,mBAAAA,KACR/B,SAAS+B,mBAAAA,KACTE,MAAAA,EAAAA;AAE6B,kBAAA,OAApBE,mBAAkCJ,mBAAAA,QAC3CA,mBAAAA,IAAmB,IAAII,oBAAAA,OAIZC,cAAgB,OAAeL,mBAAAA,IAAiBM,kBAAkBD,gBAC3E5D,GAAQ6D,SAASN,mBAAAA,IAAiBM,UAAAA,OAO3BC,WAAa,QACtB9D,GAAQ+D,cAAcR,KAAKR,kBAAkB,YAAY,SAG3DiB,MAAMT,mBAAAA,KAAWvD,EAAAA,EACdiE,KAAM3D,CAAAA,OAAAA;;AACLA,aAAAA,GAAIkB,QAAQP,QAAQ,CAACrB,IAAYsB,OAAAA;AAC/BqC,2BAAAA,IAAAA,mBAAAA,MAAoB,GAAGrC,EAAAA,KAAQtB,EAAAA;;MAAK,CAAA,GAEtC2D,KAAKV,SAASvC,GAAIuC,QAClBU,KAAKT,aAAaxC,GAAIwC,YACtBS,KAAKb,aAAa,IAClBa,MAAAA,KAAKf,uBAALe,gBAAAA,IAAAA,YACOG,IAAWpD,GAAI4D,KAAAA,IAAS5D,GAAI6D,YAAAA;KAAAA,EAEpCF,KAAMG,CAAAA,OAAAA;;AACkB,kBAAA,OAAZA,KACTb,KAAKZ,eAAeyB,KAEpBb,KAAK9C,WAAW2D,IAElBb,KAAKb,aAAa,IAClBa,MAAAA,KAAKf,uBAALe,gBAAAA,IAAAA;IAA0B,CAAA,EAE3Bc,MAAOhE,CAAAA,OAAAA;;AACW,uBAAbA,GAAI/B,QAKRiF,MAAAA,KAAKhB,YAALgB,gBAAAA,IAAAA,WAAelD,OAJbkD,UAAKjB,YAALiB;IAIgB,CAAA;EAExB;AAAA;AArFAP;AACAC;AACAC;AACA1B;AACA2B;AACAC;AACAC;ACxBK,IAAMiB,IACe,cAAA,OAAnBC,iBAAiC,QAAmB;AADtD,IAKDC,KAA6B,UAAZF,IAAoBC,iBAAiBlC;AALrD,IAOMoC,IAA6B,CAACxE,GAASyE,MAAAA;AAClD,QAAMhG,KAAOuB,EAAQD,SACfA,KAAUC,EAAQV,gBAAgB,mBAAmBb,EAAAA,GACrDiG,KAAc,CAGd,GAAAC,KAAmB3E,EAAQV,gBAAgB,oBAAA,QAA+B,EAC9E+E,SAAAA,GACArE,SAAAA,EAAAA,CAAAA;AAKF,MAAI2E,IAAkB;AACpB,UAAMC,KAAUC,WAAWJ,GAAU,GAAG,MAAME,EAAAA;AAE9C,WAAO,EAAClE,OADO,MAAMqE,aAAaF,EAAAA,EAAAA;EAEpC;AAGI,MAAAG,KAAM,IAAIR;AAEKQ,EAAAA,cAAA3C,KAAqC,YAAA,OAAlBrC,GAAQgE,SAC5CgB,GAAIC,QAAQjF,GAAQgE,OAAOhE,GAAQqD,kBAAAA,IAAkB;AAGvD,QAAM7B,KAAUxB,GAAQwB,SAClB0D,KAASlF,GAAQmF;AAGvB,MAAIC,KAAAA,OACAC,IAAAA,OACAC,IAAAA;AAGJ,MAAAN,GAAIzC,UAAWrD,CAAAA,OAAAA;AAGXqG,MADEP,cAAe3C,IAEfnD,cAAiB6B,QACb7B,KACA,IAAI6B,MAAM,8CAA8Cf,GAAQiD,GAAAA,IAAO,EAACuC,OAAOtG,GAAAA,CAAAA,IAInF,IAAI6B,MACF,8CAA8Cf,GAAQiD,GAAAA,GACpD/D,GAAMuG,mBAAmB,IAAIvG,GAAMmG,MAAAA,OAAanG,GAAMwG,KAAAA,wBAA6B,EAAA,EAAA,CAAA;EAEvF,GAINV,GAAIvC,YAAavD,CAAAA,OAAAA;AACfqG,MACE,IAAIxE,MACF,6CAA6Cf,GAAQiD,GAAAA,GACnD/D,GAAMuG,mBAAmB,IAAIvG,GAAMmG,MAAAA,OAAanG,GAAMwG,KAAAA,wBAA6B,EAAA,EAAA,CAAA;EAEvF,GAGJV,GAAI1C,UAAU,MAAA;AACDqD,MAAAA,IAAA,GACXP,KAAAA;EAAU,GAGZJ,GAAIxC,qBAAqB,MAAA;AA6EvB0C,IAAAA,OAAAS,EAAAA,GACAhB,GAAOiB,SAASd,WAAW,MAAMe,EAAe,iBAAA,GAAoBX,GAAOU,MAAAA,IAAAA,CA1E5DR,MAAmB,MAAnBJ,GAAItC,cAKA,MAAfsC,GAAInC,UAsHV,WAAA;AACM,UAAA,EAAAuC,MAAWC,KAAUC,IAIzB;AAAI,YAAe,MAAfN,GAAInC,OAEN,QAAA,KADQ0C,EAAA,IAAIxE,MAAM,mBAAA,CAAA;AAKpB4E,UAAAA,GACAN,IAAAA,MACAX,EAAS,MAzBF,EACLjB,MACEuB,GAAIvE,aACkB,OAArBuE,GAAIpC,gBAA4C,WAArBoC,GAAIpC,eAA0BoC,GAAIrC,eAAe,KAC/EM,KAAKjD,GAAQiD,KACbD,QAAQhD,GAAQgD,QAChBxB,SAASsE,EAAad,GAAIxB,sBAAAA,CAAAA,GAC1BuC,YAAYf,GAAInC,QAChBmD,eAAehB,GAAIlC,WAAAA,CAAAA;MAiBU;IACjC,EAhIEmD;EAAO,GAITjB,GAAIkB,KACFlG,GAAQgD,QACRhD,GAAQiD,KAAAA,IACR,GAIF+B,GAAIjC,kBAAAA,CAAAA,CAAoB/C,GAAQ+C,iBAG5BvB,MAAWwD,GAAImB,iBACjB,YAAWjF,MAAOM,GAEJA,CAAAA,GAAA4E,eAAelF,EAAAA,KACzB8D,GAAImB,iBAAiBjF,IAAKM,GAAQN,EAAAA,CAAAA;AAKxC,SAAIlB,GAAQqG,YACVrB,GAAIpC,eAAe,gBAIrB3C,EAAQV,gBAAgB,aAAa,EAACS,SAAAA,IAASsE,SAAAA,GAAS7F,SAASuG,IAAK/E,SAAAA,EAAAA,CAAAA,GAEtE+E,GAAIsB,KAAKtG,GAAQyD,QAAQ,IAAA,GAGrByB,OACFP,GAAO4B,UAAUzB,WAAW,MAAMe,EAAe,WAAA,GAAcX,GAAOqB,OAAAA,IAGjE,EAAC7F,OAER,WAAA;AACY0E,IAAAA,KAAAA,MAENJ,MACFA,GAAItE,MAAAA;EAER,EAAA;AAEA,WAASmF,EAAeW,IAAAA;AACXlB,QAAAA,MACXN,GAAItE,MAAAA;AACJ,UAAMF,KAAa,IAAIO,MACZ,sBAATyF,KACI,kCAAkCxG,GAAQiD,GAAAA,KAC1C,sCAAsCjD,GAAQiD,GAAAA,EAAAA;AAEpDzC,IAAAA,GAAMgG,OAAOA,IACbvG,EAAQtB,SAAS6B,MAAMvB,QAAQuB,EAAAA;EACjC;AAWA,WAASmF,EAAWc,IAAAA;AAAAA,KAEdA,MAASrB,MAAYJ,GAAItC,cAAc,KAAKiC,GAAO4B,YACrDxB,aAAaJ,GAAO4B,OAAAA,GAGlB5B,GAAOiB,UACTb,aAAaJ,GAAOiB,MAAAA;EAExB;AAEA,WAASL,EAAQ/E,IAAAA;AACX,QAAA6E,EACF;AAIFM,MAAAA,IAAW,GACXN,IAAAA,MACEL,KAAc;AAIhB,UAAM3E,KAAOG,MACX,IAAIO,MAAM,2CAA2Cf,GAAQiD,GAAAA,EAAAA;AAI/D5C,IAAAA,GAAIqG,iBAAAA,MACJrG,GAAI5B,UAAUuB,IACd0E,EAASrE,EAAAA;EACX;AA6BA;AAvNK,ICFMsG,IAAQ,CACnB3I,IAA8B,CAAA,GAC9BC,IAA2BwG,MACb1G,EAAgBC,GAAgBC,CAAAA;ADDzC,ICIM2I,IAAc;",
  "names": ["channelNames", "middlehooks", "createRequester", "initMiddleware", "httpRequest", "loadedMiddleware", "middleware", "reduce", "ware", "name", "processOptions", "validateOptions", "request", "opts", "channels", "target", "subscribers", "Object", "create", "nextId", "publish", "event", "id", "subscribe", "subscriber", "createPubSub", "applyMiddleware", "hook", "defaultValue", "args", "bailEarly", "value", "i", "length", "handler", "options", "context", "ongoingRequest", "unsubscribe", "ctx", "err", "res", "reqErr", "error", "response", "abort", "l", "returnValue", "use", "newMiddleware", "Error", "onReturn", "forEach", "key", "push", "clone", "trim", "string", "replace", "headers", "result", "headersArr", "split", "row", "index", "indexOf", "slice", "toLowerCase", "arg", "prototype", "toString", "call", "FetchXhr", "onabort", "onerror", "onreadystatechange", "ontimeout", "readyState", "responseText", "responseType", "status", "statusText", "withCredentials", "method", "url", "resHeaders", "controller", "init", "useAbortSignal", "_async", "this", "getAllResponseHeaders", "body", "textBody", "AbortController", "EventTarget", "signal", "document", "credentials", "fetch", "then", "text", "arrayBuffer", "resBody", "catch", "adapter", "XMLHttpRequest", "XmlHttpRequest", "httpRequester", "callback", "timers", "injectedResponse", "cbTimer", "setTimeout", "clearTimeout", "xhr", "setInit", "delays", "timeout", "aborted", "loaded", "timedOut", "onError", "cause", "lengthComputable", "total", "stopTimers", "socket", "timeoutRequest", "parseHeaders", "statusCode", "statusMessage", "onLoad", "open", "setRequestHeader", "hasOwnProperty", "rawBody", "send", "connect", "code", "force", "isNetworkError", "getIt", "environment"]
}
